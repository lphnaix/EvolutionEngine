1. 总体技术栈清单

语言

引擎 Runtime：C#（.NET 8 或 7）

工具 & 管线：Python 3.11+

图形 / 平台（建议，不强制）

C# 层：MonoGame / FNA / SDL2-CS + OpenGL/DirectX（二选一即可）

输入：图形框架自带输入接口，封一层 IInputManager

序列化 & 配置

JSON：System.Text.Json 或 Newtonsoft.Json

也可预留 YAML（Python 编辑时用 PyYAML，导出为 JSON 给引擎）

数据库

SQLite：System.Data.SQLite 或 Microsoft.Data.Sqlite

Python 端：sqlite3 标准库

Python 库（工具层）

配置编辑/校验：pydantic / jsonschema（可选）

数据分析：pandas / matplotlib（平衡性分析用）

Perlin 噪声：noise 包或自写

GUI（以后）：PyQt / Tkinter / web 前端都行

2. C# Runtime 子系统设计 & 技术清单

下面按“子系统 → 职责 → 主要类/命名空间建议 → 技术点”来列。

2.1 核心基础层
2.1.1 应用 / 主循环 / 时间

职责

统一游戏主循环：输入 → 更新 → 渲染

管理全局 GameState（主菜单、游戏内、暂停…）

提供 GameTime（dt、累计时间）

建议命名空间 / 类

Engine.Core.Game

Engine.Core.GameLoop

Engine.Core.GameTime

Engine.Core.IGameSystem（统一 Update(dt) 接口）

技术点

固定 / 半固定时间步长（如逻辑 60 FPS，渲染尽量高）

使用 Stopwatch 控制 dt

子系统注册表：按注册顺序调用 Update

2.1.2 日志 & 事件总线

职责

标准化日志输出（调试、错误、性能等）

简单事件总线（pub/sub）

建议类

Engine.Core.ILogger

Engine.Core.LogLevel

Engine.Core.EventBus

技术点

日志输出到 Console + 文件

EventBus 用委托/泛型实现，注意避免内存泄漏

2.1.3 平台 & 输入

职责

封装图形框架的窗口 & 输入为统一接口

建议类

Engine.Platform.IInputManager

Engine.Platform.KeyboardState

Engine.Platform.MouseState

技术点

由 MonoGame/FNA 等实际实现输入，外部只使用 IInputManager

对玩家控制组件只暴露“动作级”接口（移动方向、开火、使用技能等）

2.2 表现层：渲染 & 摄像机 & UI
2.2.1 渲染 & 光照系统

职责

提供统一 IRenderer 接口，负责：

2D sprite 绘制

3D 地形绘制（如使用 heightmap → mesh）

光源 & 简单光照

后期可加后处理

类/命名空间

Engine.Rendering.IRenderer

Engine.Rendering.Camera

Engine.Rendering.SpriteBatchWrapper

Engine.Rendering.Light, LightType

Engine.Rendering.Material

技术点

初版可用纯 2D + shader 模拟光照（normal map）

后续地形 mesh + 正交/小 FOV 透视相机

尽量把 shader 细节藏在 Renderer 内部

2.2.2 摄像机系统

职责

世界坐标 → 屏幕坐标

跟随玩家、震屏、缩放

类

Engine.Rendering.Camera

Engine.Rendering.CameraController（跟随逻辑）

技术点

多相机支持（主摄像机 + UI 摄像机），后续可扩展

震屏用一个小的“抖动偏移叠加”

2.2.3 UI / HUD 系统

职责

基础元素（文本、图标、条形条、按钮）

HUD（血条、资源条、技能栏、对话框）

类

Engine.UI.UIRoot

Engine.UI.UIElement 基类及派生

Engine.UI.Hud, Engine.UI.DialoguePanel

技术点

初期可用极简“手写 UI 系统”

以后可替换为更成熟 UI 框架，但接口要独立

2.3 世界 & 实体 & 地形
2.3.1 场景 / 世界管理

职责

管理当前世界（地形+实体+触发器）

场景切换、加载/卸载

类

Engine.World.World

Engine.World.Scene

Engine.World.SceneManager

技术点

Scene 持有：地形、实体列表、触发器列表

World/Scene 与 Data 层交互加载配置

2.3.2 地形 / 地图系统（含 Perlin 噪声）

职责

定义 TileMap / HeightMap 数据结构

调用“生成器”按 seed+参数生成地图

提供可走性 / 高度 / 地形类型查询

类

Engine.World.Terrain.TerrainMap

Engine.World.Terrain.Tile

Engine.World.Terrain.BiomeType

Engine.World.Terrain.ITerrainGenerator

Engine.World.Terrain.PerlinTerrainGenerator

技术点

噪声实现可在 C# 内重写 Perlin（和 Python 端参数保持一致）

区分静态地形数据 vs 运行时装饰物实例

预留多个生成器实现（地牢、岛屿等）

2.3.3 实体系统（Entity / Component）

职责

管理所有动态对象

支持组件组合式扩展行为

类

Engine.World.Entities.Entity

Engine.World.Entities.IComponent

示例组件：

TransformComponent

RenderComponent

PhysicsComponent（运动学）

CharacterStatsComponent

InventoryComponent

AIComponent 等

技术点

不必照搬复杂 ECS，轻量组件模式即可

注意组件生命周期（初始化/更新/销毁）

2.3.4 碰撞 / 空间查询

职责

形体碰撞检测

射线检测（射击、视线）

区域查询（AOE）

类

Engine.World.Collision.ICollisionWorld

Engine.World.Collision.Collider

Engine.World.Collision.RaycastHit

技术点

初版用简单网格 + AABB/圆形

以后可切换到 Box2D/其他物理库，只要实现 ICollisionWorld 即可

2.4 战斗 & 角色 & AI
2.4.1 角色属性 & 资源系统（Stats & Resources）

职责

管理角色 Stats（攻击、防御、移动速度等）

管理 HP/MP/体力等资源

类

Engine.Gameplay.Stats.StatType, StatCollection

Engine.Gameplay.Resources.ResourceType, ResourcePool

Engine.Gameplay.Components.CharacterStatsComponent

技术点

Stats 来源：基础 + 装备 +Buff + 被动

ResourcePool 支持：当前值/最大值/恢复规则

2.4.2 状态效果系统（Buff / Debuff）

职责

附加/移除/更新 Buff/Debuff

修改属性、周期性触发效果、限制行为

类

Engine.Gameplay.StatusEffect.StatusEffect

Engine.Gameplay.StatusEffect.StatusEffectType

Engine.Gameplay.Components.StatusEffectComponent

技术点

状态定义来自配置（持续时间、叠加上限、效果类型）

内部使用调度器更新剩余时间

2.4.3 技能系统（Skills / Abilities）

职责

根据配置定义技能

管理冷却 / 消耗 / 施放流程

类

Engine.Gameplay.Skills.SkillDef

Engine.Gameplay.Skills.SkillInstance

Engine.Gameplay.Components.SkillCasterComponent

技术点

技能定义与配置文件映射（由 Data 层加载）

技能效果通过组合：伤害 + 状态效果 + 生成实体 等调用其他系统

2.4.4 战斗 / 射击框架

职责

武器系统、弹道系统、伤害结算、阵营判定

类

Engine.Gameplay.Combat.WeaponDef, WeaponInstance

Engine.Gameplay.Combat.Projectile

Engine.Gameplay.Combat.DamageInfo

Engine.Gameplay.Combat.Faction

技术点

支持实体弹道（子弹）和射线（命中扫描）

伤害计算依赖 Stats（攻击防御/暴击等）

2.4.5 AI & 导航

职责

为敌人/NPC 提供寻路和行为决策能力

类

Engine.Gameplay.AI.INavigationProvider

Engine.Gameplay.AI.Path（A* 结果）

Engine.Gameplay.AI.AIController

可选：StateMachine / BehaviorTree 基类

技术点

导航使用 Tile 可走性图生成 NavGrid

AI Controller 作为组件，读取玩家位置/任务状态等

2.4.6 玩家控制组件（PlayerController）

职责

把输入转换为角色行为：移动、攻击、施放技能、交互

类

Engine.Gameplay.Player.PlayerControllerComponent

技术点

不直接访问图形/窗口层，只依赖 IInputManager

与 UI/HUD 同步（更新血条、技能冷却显示）

2.5 物品 / 装备 / 经济 / 奖励
2.5.1 物品系统（Items）

职责

定义所有物品类型 & 使用效果

类

Engine.Gameplay.Items.ItemDef

Engine.Gameplay.Items.ItemType

Engine.Gameplay.Items.ItemUseContext

技术点

定义结构对齐 Python 端数据模型（方便工具生成）

使用效果调用资源/状态/事件系统

2.5.2 背包 / 存储（Inventory / Storage）

职责

管理实体持有物品（玩家背包、箱子、商店库存）

类

Engine.Gameplay.Inventory.Inventory

Engine.Gameplay.Components.InventoryComponent

技术点

物品堆叠 / 容量限制

存档时序列化为记录写入 SQLite

2.5.3 装备系统（Equipment）

职责

管理装备槽位与装备物品的挂载

类

Engine.Gameplay.Equipment.EquipmentSlotType

Engine.Gameplay.Equipment.EquipmentSet

Engine.Gameplay.Components.EquipmentComponent

技术点

通过装备影响 Stats / 技能（例如添加被动）

2.5.4 经济 / 商店 / 奖励

职责

货币 & 商店逻辑

统一发放奖励（物品/货币/经验/解锁）

类

Engine.Gameplay.Economy.CurrencyType

Engine.Gameplay.Economy.Wallet

Engine.Gameplay.Economy.Shop

Engine.Gameplay.Rewards.RewardDef, RewardExecutor

技术点

奖励系统作为“总入口”：任务、掉落、事件都调用它

商店实际只是一个特殊“物品集合 + 价格规则”

2.6 NPC / 对话 / 任务 / 事件
2.6.1 NPC 系统

职责

管理 NPC 定义/实例、交互入口、行为模式

类

Engine.Narrative.NpcDef

Engine.Narrative.NpcInstance

Engine.Narrative.Components.NpcComponent

2.6.2 对话系统

职责

管理对话数据、会话流程、选项分支

类

Engine.Narrative.Dialogue.DialogueDef

Engine.Narrative.Dialogue.DialogueNode, Choice

Engine.Narrative.Dialogue.DialogueRunner

技术点

条件/动作中调用任务系统、事件系统、变量系统

UI 层只做展示和选择，逻辑在 DialogueRunner

2.6.3 任务系统

职责

任务定义、状态跟踪、完成条件检查

类

Engine.Narrative.Quests.QuestDef

Engine.Narrative.Quests.QuestState

Engine.Narrative.Quests.QuestManager

技术点

与事件系统协作：杀怪/进入区域→更新任务进度

完成后调用 RewardExecutor

2.6.4 事件 / 触发器

职责

通用 Condition + Action 系统

类

Engine.Narrative.Events.EventCondition

Engine.Narrative.Events.EventAction

Engine.Narrative.Events.TriggerZone

Engine.Narrative.Events.EventManager

技术点

条件与动作可通过配置驱动，复杂逻辑留给脚本层

触发器可以是场景内的实体（碰撞触发）

2.7 数据 & SQLite
2.7.1 配置读取层

职责

从 JSON/YAML/DB 加载配置→ C# DTO

类

Engine.Data.Config.GameConfigProvider（实现 IGameConfigProvider 接口）

DTO：ItemConfig, SkillConfig, QuestConfig 等

技术点

Python 工具负责生成 JSON/YAML/DB 条目

C# 只做解析 + 缓存

2.7.2 存档 & 日志（SQLite）

职责

把运行时状态持久化到 SQLite

读取存档 / 记录行为日志

类

Engine.Data.SaveRepository

Engine.Data.LogRepository

技术点

建议用较薄的 ORM（Dapper）或者裸 SQL + 简单封装

表结构按前面说的 Save/PlayerState/Inventory/QuestState 等划分

3. Python 工具层：子系统设计 & 技术清单简表
3.1 通用工具库

tools/common/data_models.py

定义 Python 侧的配置数据类（与 C# DTO 对齐）

tools/common/sqlite_helper.py

封装 SQLite 连接 & 常用查询

3.2 配置编辑 / 校验子系统

职责

编辑/生成物品、技能、任务、NPC、对话等配置

保存为 JSON/YAML

校验结构合法性

技术

pydantic 或 dataclasses + 手写校验

命令行工具为主，后续可加 GUI

3.3 地形参数调优 / 预览子系统

职责

用与 C# 一致的 Perlin 算法测试不同参数→生成高度图/地形图

输出 TerrainConfig.json

技术

noise 或自写 Perlin

matplotlib 生成高度图预览

可导出 PNG + JSON

3.4 平衡性分析子系统

职责

读取 SQLite 中的 CombatLog

统计：

各技能/武器伤害分布

敌人击杀/死亡曲线

任务完成率等

技术

pandas

matplotlib / seaborn

3.5 资源/配置打包子系统

职责

将散落配置归并→生成引擎用的大 JSON 或 DB 表

校验引用关系（物品/技能/任务/NPC/id 是否存在）

技术

Python 命令行脚本 + JSON/YAML 处理 + SQLite

4. 补充说明 / 技术释义（v0.1 防踩坑）

- 时间步长：逻辑目标 60 FPS，半固定步长，建议 clamp dt 在 1/90 ~ 1/30 秒并用累加器；渲染可变帧率，逻辑与渲染解耦。
- 坐标/地形：世界 XY 为平面，Z 为高度；TileMap 与 HeightMap 若同时存在，使用同一 tile 尺寸（≈1 米）与网格索引，避免“渲染网格”和“导航网格”尺寸不一致。
- 输入抽象：IInputManager 面向“动作”而非键值；玩家控制组件不直接读硬件键码，为后续改键/手柄留接口。
- 配置/ID：所有配置文件 UTF-8；ID 用字符串且大小写敏感、不含空格，推荐下划线命名；跨语言 DTO 要保持字段名/类型对齐。
- 噪声一致性：Python 与 C# 的 Perlin/噪声实现需共享同一公式和 seed，避免生成结果不一致；随机源应可注入。
- SQLite：时间字段使用 UTC（Unix 时间戳）；写操作用事务；表字段应有 NOT NULL/默认值以避免脏数据。
- 事件总线：订阅时注意取消订阅，避免持有引用导致内存泄漏。
