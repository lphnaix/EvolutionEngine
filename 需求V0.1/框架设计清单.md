0. 引擎总体定位

视角：俯视 / 半俯视（Top-down / Slight Isometric）

移动：全向连续移动（360°，非走格子）

世界：

随机生成地形（Perlin 噪声等）

有高度 / 地形类型 / 可走性 / 生物群系等信息

战斗：

支持射击要素（子弹、射线、武器、敌人）

不引入完整物理引擎，采用轻量运动学 + 碰撞系统

表现：

HD-2D 风格：2D 角色 & 贴图，配合 3D 光照 / 现代视效

RPG/养成：

NPC、对话、任务、装备、经济、物品、技能、成长等完整闭环

目标：

数据驱动、模块化、可复用的“引擎”，而不是一次性脚手架

多个游戏可以共用同一套核心，只换资源 & 配置 & 脚本

术语 / 默认约定（v0.1 防踩坑）

- 坐标系：世界坐标 XY 为地面平面，Z 为高度，正 Z 向上；1 tile ≈ 1 世界单位（约 1 米），高度/可走性共享同一 tile 网格。
- 时间步长：逻辑目标 60 FPS，半固定步长，建议 clamp dt 在 1/90 ~ 1/30 秒；渲染可变帧率，逻辑/渲染解耦。
- 随机性：地形/掉落/AI 等随机都接受 seed 参数，可重现；避免使用“隐式全局随机”。
- 资源/配置 ID：统一用字符串 ID（大小写敏感，不含空格），配置文件用 ID 作为 key；运行时代码不写死文件路径。
- 数值单位：距离用米（世界单位），时间用秒，角度计算默认用弧度；如需偏离需在配置注明。
- 编码/路径：所有文本配置用 UTF-8，路径以正斜杠书写，避免平台差异。

1. 运行时基础层（Runtime Foundation）
1.1 应用 / 生命周期管理

管理主循环：处理输入 → 更新逻辑 → 渲染 → 控制帧率

负责引擎启动 / 关闭：

初始化各子系统（资源、渲染、音频、脚本等）

按顺序释放资源

管理顶层游戏状态：

如：启动画面 / 主菜单 / 游戏中 / 暂停 / 设置 / 结算 等

提供统一 update(dt) 风格的子系统更新机制（概念上）

1.2 资源 / 资产管理（Asset System）

统一管理：

贴图、模型（若有）、音效、音乐

配置文件（物品、任务、技能、敌人、地形规则等）

对话脚本、事件/关卡脚本

通过资源 ID访问资源，而不是到处写硬编码路径

做好：

缓存/复用，同一资源只加载一次

支持简单的“资源包”概念（便于 DLC / Mod）

1.3 日志 / 调试 / 诊断

日志等级：debug / info / warn / error

可选 on-screen 调试信息：

FPS

实体数量

当前场景 ID

后续可扩展：

内置 debug overlay/控制台

对象 Inspector（查看某个实体所有组件数据）

2. 世界 & 实体层（World & Entities）
2.1 场景 / 世界管理（Scene / World System）

管理多个场景/世界：

不同地图 / 不同地形 seed / 不同关卡

每个场景中统一管理：

地形数据

静态物件（树、石头、建筑）

动态实体（玩家、NPC、敌人、投射物）

触发器 / 事件区域等

提供查询接口：

给定位置：地形高度 / 类型 / 是否可走

某区域内实体列表

射线/视线查询（与碰撞系统协作）

2.2 地形 / 地图系统（Terrain & Map System）

这是引擎的核心之一。

数据结构：

基于网格（Tile）的地形数据

每个 tile 至少包含：

高度值（height）

地形类型（草地、沙漠、岩石、雪、道路、水面等）

可走性标记（可走 / 半可走 / 不可走 / 仅飞行可走 等）

生物群系 / 区域标签（森林、荒原、城镇、地牢入口等）

其他可选信息：装饰物分布、危险度系数等

随机生成（Perlin 噪声等）：

抽象“地形生成器”接口：

输入：seed + 参数集合（噪声频率、振幅、octaves、阈值、offset…）

输出：地形高度场 + 地形类型分布 + 生物群系信息

数据驱动的规则：

噪声 / 高度 区间 → 地形类型

地形类型 → Tile 贴图方案 / 阻挡规则 / 装饰生成概率

支持不同生成模式：

大陆/岛屿式随机世界

特殊区域（城镇、营地、地牢入口）“镶嵌”在随机地形里

种子管理：

支持 seed 固定重现同一地图

支持 seed 写入存档

与其他系统的协作：

为 AI/导航提供可行走区域

为战斗提供高度差信息（可选：高差影响命中/视线）

为渲染系统提供：

mesh / tile 渲染数据

地形材质 ID / 法线 / 光照参数

2.3 实体系统（Entity System）

所有动态对象的统一模型：

玩家、敌人、NPC、子弹、陷阱、机关、掉落物等

每个实体：

唯一 ID

基础属性：位置(x,y,z)、朝向、阵营、生命周期状态

使用组件组合扩展能力：

渲染组件（sprite / billboard / mesh）

碰撞组件

移动组件

角色属性组件（Stats）

生命/资源组件

技能组件

AI 组件

NPC 组件

背包/装备组件

等等

目标：

新增实体类型 → 尽量只靠组合已有组件 + 配置数据完成，不改引擎核心

2.4 时间 / 调度系统（Game Time & Scheduler）

提供统一时间源（游戏逻辑时间、真实时间）

管理定时 / 延时任务：

N 秒后执行某动作

周期性行为（每秒伤害、每隔一段时间刷怪）

便于：

事件系统调度

技能/CD 计时

Buff 持续时间管理

3. 表现层（Rendering & Presentation）
3.1 渲染 & 光照系统（Rendering & Lighting）

目标：2D 角色 + 3D 光照 / 后处理（HD-2D 感）

支持：

地形以 3D 方式渲染（高度场生成 mesh）

角色 / NPC / 敌人 / 投射物为 2D sprite / billboard

装饰物支持简单 3D/2D 混合

光照：

全局环境光（颜色/强度）

至少一种主光源（平行光/定向光）

支持若干点光源（火把、灯、爆炸闪光）

与法线贴图结合以增强立体感（可选）

渲染层/通道：

地形层

静态物件层

动态角色层

特效层（子弹轨迹、爆炸、魔法）

UI 层

后处理插入点（预留）：

景深

Bloom

雾效

色调映射

3.2 摄像机系统（Camera System）

跟随指定实体（通常是玩家）

支持：

平滑跟随 / 视差效果

边界限制（不超出地图）

屏幕震动（爆炸/受击）

缩放 / 拉近拉远（战斗/探索模式）

渲染/裁剪依赖摄像机视口，而不是直接使用屏幕坐标

3.3 基础 UI / HUD 系统

支持基本 UI 元素：

文本、图标、进度条、按钮

HUD：

玩家血量条、施法资源条

技能栏 & 冷却显示

准星 / 锁定指示

简易小地图 / 指南针（可选）

界面：

暂停菜单

设置界面

对话框容器（与对话系统配合）

背包/装备/商店界面（未来 GUI 升级版）

4. 类型特化：战斗 / AI / 碰撞（Game-Type Core）
4.1 碰撞 & 空间查询系统（Collision & Query）

管理：

静态障碍物（地形阻挡、墙体）

动态碰撞体（角色、子弹、陷阱）

提供查询：

形体碰撞检测（圆 / AABB / 其他简单形状）

射线检测（射击线、视线检测）

区域查询（范围伤害 / AOE 查敌）

在设计上作为“抽象物理层”：

未来如果切换到真正物理引擎，只替换这层实现即可

4.2 战斗 / 射击框架（Combat / Shooting Framework）

武器系统：

武器类型数据：

单发、连射、散射、喷射、导弹、持续光束等

参数：

伤害、射速、弹速、弹药容量、装填时间、射程、精度/散布等

与装备系统打通：武器通常是装备物

弹道 / 命中系统：

方式：

实体弹道：在世界中飞行（子弹实体）

瞬时射线：命中即刻判定（步枪、狙击）

范围判定：圆形/扇形/矩形 AOE

命中后：

调战斗系统计算伤害

触发特效（命中特效、声音等）

伤害 & 生命系统：

通用伤害模型：

基础伤害 + 攻击方属性 + 技能系数 − 防御方属性

支持暴击/格挡/多段伤害等（可配）

生命/护盾：

HP / Shield / 其他特殊资源

HP 归零 → 触发死亡/倒下/特殊事件

阵营系统（Faction / Allegiance）：

阵营：

玩家

敌对（怪物、敌军）

中立（平民、某些 NPC）

环境（机关、陷阱等）

决定：

谁可以攻击谁

技能/AOE 是否作用于友方

4.3 AI / 导航系统（AI & Navigation）

导航：

基于地形可走区域的寻路（例如网格上的 A*）

提供：从 A 至 B 的路径 / 是否可达

AI 框架：

基本状态机（巡逻 / 追击 / 攻击 / 逃跑 / 返回等）

可升级为行为树等更复杂逻辑

NPC / 敌人 AI：

巡逻路线

发现玩家 → 追击/攻击

血量低 → 逃跑/求援

根据任务状态调整行为（例如变为友好）

5. 角色 & 成长层（Characters & Progression）
5.1 角色属性系统（Stats）

定义角色属性：

基础属性：力量/敏捷/智力，或任意自定义集合

战斗属性：最大 HP、最大资源、攻击力、防御力、暴击率、移动速度等

抵抗类属性：物理/魔法/元素/控制抗性（可选）

来源合成：

角色基础 → 等级成长 → 装备 → Buff/Debuff → 被动技能

对外提供当前“最终属性”的统一查询接口

5.2 生命 & 施法资源系统（HP / Resources）

管理不同资源条：

HP（生命值）

MP / Mana（法力）

耐力 / 体力（Stamina）

其他自定义资源（怒气、能量、专注等）

每种资源：

当前值 / 最大值

自然恢复 / 攻击回复 / 事件驱动回复规则

与技能/道具联动：

施放技能前检查资源是否足够

药物/法术可恢复或消耗特定资源

5.3 状态效果系统（Buff / Debuff）

维护角色身上的所有状态：

增益：加攻击 / 防御 / 速度 / 恢复加速等

减益：中毒 / 灼烧 / 流血 / 减速 / 禁止施法等

状态属性：

来源（技能 / 药物 / 装备 / 环境）

持续时间 / 是否永久

是否可叠加 / 最大层数

是否可驱散 / 驱散类型

作用方式：

修改属性（增加或减少某些 stats）

周期性触发（每秒掉血 / 每秒回复）

限制行为（禁止移动/施法等）

5.4 技能系统（Skill / Ability System）

技能定义：

ID、名称、图标、描述

技能类型：单体 / AOE / 投射物 / 光束 / 支援 / 控制 等

施放形式：即发 / 引导 / 蓄力 / 连击

消耗的资源类型与数量

冷却时间 / 充能次数

目标筛选：自/友/敌/地面/范围

效果：伤害、治疗、增益、减益、召唤实体、位移等（调用战斗/状态系统实现）

技能管理：

每个角色可用技能列表

冷却计时

施放流程控制（前摇/后摇、中断条件）

5.5 角色成长系统（Level / Experience / Talent）

跟踪：

经验值 / 等级

属性点 / 技能点

升级逻辑：

升级时自动/手动增加属性

解锁新技能或技能升级

与任务/奖励系统结合：

任务、战斗、探索给予经验/点数

成长改变战斗表现与探索能力

5.6 玩家控制组件（Player Controller）

将输入设备（键盘/鼠标/手柄）映射为：

移动（方向、速度）

开火 / 施法 / 使用技能

使用药物/道具

切换武器/技能

交互（与 NPC / 场景物体）

驱动摄像机跟随与 UI 更新：

更新 HUD（血量、资源、技能冷却等）

6. 物品 / 装备 / 经济系统（Items / Equipment / Economy）
6.1 物品系统（Item System）

定义所有可取得物品：

基础：ID、名称、描述、图标、稀有度、最大堆叠数

类型：

消耗品（药水、卷轴）

装备（武器、防具、饰品）

材料（打造/合成）

任务物品

特殊（钥匙、地图碎片等）

使用效果：

立即效果：回复 HP/资源、立刻伤害等

延迟/持续效果：添加 buff/debuff

触发事件：开启机关、推进任务

6.2 背包 / 仓库系统（Inventory / Storage）

管理实体持有的物品：

玩家背包

仓库 / 箱子

NPC 商店库存

支持：

添加 / 移除物品

物品堆叠 / 拆分

容量限制（格子数 / 重量）

查询接口：

是否拥有某物品/数量

为任务/交易/装备系统提供检查

6.3 装备系统（Equipment System）

槽位设计：

如：主武器、副武器、头部、身体、脚、饰品等

每个槽位可装备的物品类型受限（例如只有武器类才能放在武器槽）

装备效果：

通过属性系统修改角色 stats（攻击、防御、生命、速度等）

可赋予额外技能或被动效果（如特殊攻击、元素伤害）

与物品系统联动：装备本身是物品的一种

6.4 经济 / 货币 / 商店系统（Economy & Trading）

货币类型：

金币/银币/特种货币/声望点等

玩家经济状态：

拥有多少各类货币

商店系统：

每个商店有销售列表（物品 ID + 价格 + 库存）

买入 / 卖出逻辑：

检查货币是否足够

检查背包容量

支持价格变动（难度/声望折扣）

与奖励系统协作：

统一控制货币产出 & 消耗

6.5 奖励系统（Reward System）

通用奖励描述格式：

获得物品（id + 数量）

获得货币

获得经验 / 属性 / 技能

解锁内容（新场景/商店/配方等）

由任务、战斗掉落、探索事件等调用

执行奖励时，统一调用背包/经济/成长系统

7. NPC / 对话 / 任务 / 事件 / 叙事层
7.1 NPC 系统（NPC System）

NPC 类型定义：

身份/名称/外观（立绘、行走贴图）

行为标签：可对话、可交易、可委托任务、是否参战

NPC 实例管理：

刷新位置 / 刷新规则（固定/随机/时间表）

与地形/区域的绑定（例如某村庄范围）

行为模式：

原地待机、简单巡逻、时间表（早上在 A，晚上在 B）

根据任务/世界状态改变行为（敌对/友好）

交互入口：

玩家靠近并按键 → 触发对话 / 交易 / 任务等

7.2 对话系统（Dialogue System）

对话数据模型：

节点（Node）：文本、说话者、立绘/表情、进入/离开动作

选项（Choice）：选项文本、可见/可选条件、目标节点

条件 & 变量：

读取任务状态、世界变量、玩家属性/好感度等决定对话走向

对话会话（Conversation）：

管理当前节点、可选项、跳转

与其他系统联动：

通过对话接受/完成任务

触发事件（刷怪、开门、改变天气等）

与 NPC 系统耦合：特定 NPC → 特定对话 ID

7.3 任务系统（Quest System）

任务定义：

ID、标题、描述、类型（主线/支线/日常/隐藏）

接取条件（等级、前置任务、声望等）

完成条件：

击杀某怪若干

收集/提交物品

抵达区域 / 触发事件

与指定 NPC 对话

分阶段（Step）：多阶段任务流程

完成奖励（交给奖励系统执行）

状态管理：

未解锁 / 可接受 / 已接受 / 已完成未交 / 已交 / 失败

联动：

对话节点中接任务 / 交任务

事件系统根据任务阶段改变世界

7.4 事件 / 触发器系统（Event / Trigger System）

通用模型：

条件（Condition）：进入区域、时间到、任务状态变化、实体死亡等

行为（Action）：刷怪、播放对话、切场景、修改变量、发奖励等

事件来源：

地图上的触发器区域

NPC/对话节点

任务阶段变化

目标：

用统一、数据驱动的方式描述“脚本事件”，避免 if 地狱

8. 脚本 / 存档 / 扩展层
8.1 脚本 / 行为扩展系统（Scripting）

引擎暴露一组 API 给脚本/配置：

创建/销毁实体

修改角色属性/状态

触发技能 / 事件

控制任务推进、调整世界变量等

游戏项目把“特殊行为”、“复杂剧情逻辑”写在脚本层，而不是引擎核心

8.2 存档 / 序列化系统（Save / Load）

存档内容：

当前场景 / 世界种子 / 时间

玩家状态（位置、属性、背包、装备、任务进度、对话变量等）

世界状态（关键实体存活情况、事件触发状态）

允许：

多存档位

快速存档/读档（可选）

8.3 Mod / 扩展内容支持（规划向）

数据/资源不写死在引擎中：

支持从外部目录加载额外配置

支持覆盖默认物品/任务/地形规则等

为未来：

用户自制地图/武器/任务/剧情

第三方内容包

预留扩展点。

9. 工具 / GUI 层（暂不实现，但纳入引擎设计）

这些是“将来要做、现在要为它们在数据 & 结构上留位置”的内容。

地形 & 随机生成调参 GUI：

噪声参数、地形区间、群系规则可视化调整 + 实时预览

物品 / 装备 / 商店编辑器：

编辑物品/装备属性、掉落表、商店货架

NPC / 对话 / 任务 / 事件编辑器：

对话树可视化（节点、分支）

任务流程编辑（阶段、条件、奖励）

事件触发器编辑（条件+动作）

Debug HUD / Inspector：

实时查看某实体的组件数据、世界变量、任务状态等
