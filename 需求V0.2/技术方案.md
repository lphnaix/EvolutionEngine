0. v0.2 产出目标（整体）

在 v0.2 结束时，引擎应达到：

有明确的目标平台 & 图形后端，能稳定以 1080p/1440p、60FPS 运行（在合理硬件上）。

拥有一条可重复的配置数据管线：

Python 生成合并后的配置包

C# 通过统一接口读取

支持HD-2D 基础渲染效果：

正交相机

规范的深度/排序模型

初步光照与特效

拥有可用的音频/动画/粒子/输入映射系统，使整个游戏体验不再“哑巴+纸片”。

存档系统基于 SQLite 完成第一版正式 schema，能稳定读写一个中等复杂度的游戏状态。

有一个可内部测试的小 demo：

随机地形

基础战斗 / 技能

NPC + 对话 + 简单任务

拾取/装备/商店

BGM、音效、动画、粒子、基本 UI/HUD
全部通过 v0.2 版本的引擎功能跑起来。

1. 运行时平台与图形后端
1.1 目标平台锁定

v0.2 技术目标：

运行时平台：

OS：Windows 10+ x64

图形后端：MonoGame + DirectX 11（WindowsDX mgcb 配置）

输入设备：

必须完整支持：键盘 + 鼠标

手柄只作为未来扩展目标写入文档，不在 v0.2 落地

验收标准：

工程默认构建目标为 Windows + MonoGame

在最低配置（集显/轻量独显）上可以稳定运行 demo

文档中有清晰的“支持/不支持列表”

2. HD-2D 渲染基础能力
2.1 相机与深度模型

v0.2 技术目标：

使用 正交相机（Orthographic Camera） 作为唯一相机模型。

明确世界坐标系（XY 平面 / Z 用于高度/排序）。

使用 Z-buffer + 渲染层级 处理：地形 / 实体 / 特效 / UI 的深度关系。

验收标准：

地形与角色、子弹、装饰物不会出现明显的“遮挡错误”。

相机跟随、震屏、缩放在此模型下稳定工作。

2.2 地形渲染方案 “定型”

v0.2 技术目标：

 在文档与代码中明确地形表现路线：

 采用 HeightMap + Mesh 渲染（地形为 3D mesh，角色为 sprite/billboard），1 tile = 1 米，XY 为地面平面，Z 为高度（米）。HeightMap 分辨率与 tile 可走性图 1:1 对齐，碰撞/导航沿用 tile 可走性。

 地形渲染 API 对上暴露统一接口，不再频繁改变。

验收标准：

Engine.World.Terrain 数据结构稳定

Renderer 只针对地形提供一个清晰的 DrawTerrain(...) 入口

随机生成的地形在视觉上是统一风格、无明显 break

2.3 光照 / Normal Map / 后处理（最小版本）

v0.2 技术目标：

支持至少以下光照要素：

一般环境光（Ambient）

一种全局/主光源（简单方向光或点光）

支持为 sprite/地形预留 normal map 通道（可选用，非强制）。

后处理 pipeline 定义一个最小顺序：

Scene Pass →（可选）Bloom → UI Pass

验收标准：

代码中有 Light / Material 的基本概念

Demo 中可以通过调整光强/颜色看到画面明显变化

后处理顺序在文档中有简单示意图

3. 数据管线与配置管理
3.1 配置形态与目录结构定稿

v0.2 技术目标：

源配置：

使用 YAML/JSON 作为主编辑格式（Python 侧负责人）。

按类别分目录，如 /Data/Items/, /Data/Quests/, /Data/Skills/ 等。

源美术/音频：

/ContentSrc/Textures/, /ContentSrc/Audio/, /ContentSrc/Fonts/（mgcb 输入，纹理默认开启 mipmap，音频源为 OGG）。

构建输出：

Python 在构建时合并为统一 JSON 包，输出至 /Build/Config/xxx.json。

/Content/**.xnb 由 mgcb（WindowsDX 配置）生成，运行时通过 ContentManager 读取。

C#：

只依赖 /Build/Config/*.json + /Content/**.xnb，不直接读 /Data 或源素材。

验收标准：

构建脚本一键生成配置包。

引擎启动时仅使用构建产物，不依赖源配置目录。

3.2 C# DTO / Python 模型 / Schema 对齐策略

v0.2 技术目标：

在 Python 中定义配置数据模型（data_models.py）。

在 C# 中定义对应 DTO 类。

同步策略：人工维护 + 单元测试校验关键字段，暂不做自动代码生成。

每个配置 JSON 中包含一个 config_version 字段。

验收标准：

若 Python/ C# 侧字段不匹配，在构建或运行时能及时暴露（至少通过简单断言/测试）。

版本号在引擎启动日志中打印出来。

4. 存档 / SQLite 体系
4.1 存档 Schema v1 完成

v0.2 技术目标：

设计并实现第一版存档 schema（SQLite）：

Saves(id PK, name TEXT, created_at INT, updated_at INT, play_time INT, world_seed TEXT, schema_version INT)

PlayerState(save_id PK/FK, scene_id TEXT, pos_x REAL, pos_y REAL, pos_z REAL, hp REAL, mp REAL, level INT, exp INT)

Inventory(save_id FK, slot INT, item_id TEXT, qty INT, PRIMARY KEY(save_id, slot))

Equipment(save_id FK, slot TEXT, item_id TEXT, PRIMARY KEY(save_id, slot))

QuestState(save_id FK, quest_id TEXT, status INT, progress_json TEXT, PRIMARY KEY(save_id, quest_id))

WorldFlags(save_id FK, key TEXT, value TEXT, PRIMARY KEY(save_id, key))

CombatLog 可选（推迟实现）。

引擎支持：

新建存档

覆盖存档

从存档完整恢复：玩家位置、背包、装备、任务状态、世界关键变量。

验收标准：

实际 demo 中可以：

存一次档 → 退出 → 读档 → 回到原状态继续玩。

SQLite 文件结构稳定，必要字段都有注释/schema 文档；CRUD 由 SaveRepository 覆盖。

4.2 存档版本 & 基础安全策略

v0.2 技术目标：

为每个存档写入 schema_version（常量 SAVE_SCHEMA_VERSION = 1）。

当 schema_version 与运行时版本不一致时：拒绝加载并提示用户。

写档前自动复制旧存档为 .bak 备份。

暂不实现自动迁移/压缩/异步写入，但在文档中列入 v0.3+ 计划。

验收标准：

手动修改存档版本号为错误值，引擎能识别并拒绝加载。

5. 输入系统与玩家操作映射
5.1 动作级输入抽象

v0.2 技术目标：

定义 Action 枚举（移动、攻击、技能、交互、菜单等）。

输入系统对外提供 GetActionState(Action) 接口。

玩家控制、UI 逻辑只依赖动作枚举，不直接读键值。

验收标准：

改键位映射文件，不改代码即可调整 WASD / Arrow 等控制方式。

玩家控制层代码中不再出现“硬编码 KeyCode”的逻辑。

5.2 键位映射与配置文件

v0.2 技术目标：

使用 JSON/YAML 定义键位 → Action 映射文件（例如 /Config/input_mappings.json）。

引擎启动时加载该文件，构建映射表。

暂不提供游戏内 UI 重绑功能。

验收标准：

修改映射文件后重启游戏，控制方式随之变化。

6. 音频系统
6.1 基础音频框架

v0.2 技术目标：

实现 IAudioManager，提供：

播放/停止 BGM（支持 loop，OGG 44.1kHz，流式播放，单实例，0.5–1.0s 淡入淡出）

播放 SE 音效（OGG 源，预加载 SoundEffect，最大并发 32，同 id 默认限 4 并发）

全局音量设置（Master/BGM/SE，0–1，对数曲线）

集成 MonoGame 内置音频能力完成最小版。

验收标准：

Demo 中：

切场景时可以更换 BGM

攻击、受击、UI 操作有音效

音量调整生效

7. 动画与特效
7.1 角色动画系统

v0.2 技术目标：

实现序列帧动画：

支持 idle / move / attack / death 等基础状态

简单动画状态机：

根据角色状态/速度切换动画

将动画与渲染层打通（支持 sprite sheet）。

验收标准：

玩家与敌人至少具备“静止/移动/攻击/死亡”四种动画，并随状态切换。

7.2 粒子系统（最小功能）

v0.2 技术目标：

实现一个基础粒子系统：

可配置简单粒子发射器（位置、方向、寿命、颜色、大小变化）

用于：

子弹拖尾

爆炸效果

简单环境效果（雨/雪，可选）

验收标准：

Demo 中攻击/爆炸有粒子效果，且不会明显拖垮帧率。

8. 资源加载与简易热重载（开发向）
8.1 资源加载约定

v0.2 技术目标：

明确纹理、音频、字体、配置存放路径与命名约定：

源：/ContentSrc/Textures、/ContentSrc/Audio、/ContentSrc/Fonts（mgcb 输入）

输出：/Content/**.xnb（mgcb WindowsDX），/Build/Config/**.json（静态数据、文本）

AssetManager 统一负责 XNB + 配置的加载 & 缓存，运行时不直接读源素材。

验收标准：

所有引擎模块通过 AssetManager 获取资源，不直接对文件系统硬编码路径。

8.2 开发期配置热重载入口

v0.2 技术目标：

提供一个开发用快捷键（如 F5）触发：

重新加载配置 JSON（Items/Skills/Quests 等）

不做自动文件监控，先保证手动触发可用。

验收标准：

在运行中的 demo 中修改配置文件 → 按 F5 → 效果生效（如修改武器伤害）。

9. 文本/字体与本地化基础
9.1 文本资源管理

v0.2 技术目标：

引入 TextId，UI/对话/提示不直接写中文，而使用 key。

TextId 命名示例：ui.menu.start、dialog.npc01.hello。

使用 /Data/Texts/zh_CN.yaml 等文件定义 key → 文本映射，构建到 /Build/Config/texts_zh_CN.json。

TextManager 负责加载文本资源并提供查询接口；缺 key/缺字返回 [MISSING:<key>] 并写日志。

验收标准：

替换 zh_CN 文本文件内容即可批量修改 UI 文案；

UI 代码中不出现直写文本的大段字符串（除临时调试）。

9.2 字体与渲染

v0.2 技术目标：

集成可商用中文字体（如 Noto Sans SC），放 /ContentSrc/Fonts/NotoSansSC-Regular.ttf，由 mgcb 生成 SpriteFont。

HUD 默认字号 28，对话字号 32，覆盖常用中英标点；同一字体作为缺字回退。

验收标准：

Demo 中的中文界面在不同分辨率下清晰可读，无明显缺字/乱码。

10. 测试与诊断
10.1 Debug HUD & 控制台

v0.2 技术目标：

Debug HUD 显示：

FPS

实体数量

当前场景 ID

基础内存/负载信息（粗略即可）

Debug 控制台支持一些基础命令：

spawn_enemy

teleport

give_item

toggle_collision 等

验收标准：

按热键（如 F3/F4）能打开/关闭 Debug HUD/控制台；

基础命令执行结果立即可见（比如生成敌人、瞬移）。

10.2 最小自动化测试

v0.2 技术目标：

为以下关键逻辑编写单元测试：

属性合成（基础 + 装备 + Buff）

存档读写一致性

简单地形生成输出范围（例如高度值不越界）

建立一个“压力场景”手动基准数据：

固定数量敌人 + 粒子 + 子弹

记录一份帧率参考值，为 v0.3 性能优化做对比。

验收标准：

测试项目能通过基本单测；

压力场景在目标机器上仍能保持可玩帧率（≥ 30 FPS，目标 60）。

11. 非目标（v0.2 明确不做）

为避免 scope 膨胀，以下内容明确不在 v0.2 范围内，但会为其预留接口/设计：

引入 Lua / C# 热重载等脚本运行时

完整 Job 系统 / 多线程 AI / 异步地形生成

真正意义上的资源包、压缩加密与在线热更新

完整多语言本地化管线（只做 zh-CN）

高级 Profiler / 远程崩溃上报 / 完整 CI-CD

手柄支持 / UI 内键位重绑界面（只做配置文件级）
