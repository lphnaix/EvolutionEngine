1. 平台与图形后端
1.1 目标平台矩阵（文档）

 在 需求/子系统设计概要.md 中补充「目标平台与硬件」章节：

 v0.2 明确：

 OS：优先支持 Windows 10+（x64）

 图形 API：MonoGame + DirectX 11（WindowsDX 配置）

 输入设备：键盘 + 鼠标（手柄写成后续计划）

 推荐分辨率：1080p / 1440p，最低目标帧率 60 FPS

 最低硬件建议：集显/轻量独显的粗略级别即可描述

 标明：其他平台（Linux/macOS、手柄）放入 v0.3+ 规划。

1.2 图形后端选择与封装（代码）

 在 Engine.Platform / Engine.Rendering 中写死 v0.2 使用 MonoGame + DirectX 11（WindowsDX mgcb 配置）。

 抽象出：

 IRenderer

 IInputManager

 IGameWindow

 确保未来更换图形后端时，不影响上层模块。

2. HD-2D 渲染细节
2.1 相机 & 深度模型定稿（文档 + 代码）

 在 需求/框架设计清单.md 3.1 内明确：

 v0.2 使用 正交相机（Orthographic）

 地形 + 实体使用 Z-buffer + 层级深度 进行排序，不再依赖“按 Y 值排序”的 2D 老套路

 在 Engine.Rendering.Camera 中实现正交相机矩阵

2.2 地形表现方案

 在文档明确：

 v0.2 地形方案锁定为：HeightMap → Mesh（方案 B），1 tile = 1 米；XY 为地面平面，Z 为高度（米）。HeightMap 分辨率与 tile 可走性图 1:1 对齐，碰撞/导航仍基于 tile 可走性。

 在 Engine.World.Terrain 内：

 定下最终 Terrain 数据结构（HeightMap 字段、Tile 可走性图）。

 渲染层：提供 BuildTerrainMesh() / DrawTerrainMesh() 的统一接口；Tile 渲染接口仅作兼容层（装饰/特殊场景）。

2.3 光源 / 法线 / 后处理的最小实现

 在 需求/框架设计清单.md 中补充 v0.2 光照目标：

 至少一个全局方向光（或环境光）

 将来支持点光源，但 v0.2 可只做接口

 在 Engine.Rendering 中：

 设计 Light 结构（方向光 / 点光源 / 颜色 / 强度）

 为 sprite/地形预留 normal map 支持（纹理通道 + 材质参数）

 后处理顺序（v0.2 最小版，全部可选开启/关闭）：

 渲染场景 → 可选 Bloom → UI Overlay

 在文档中简单描述“当前 pipeline”。

3. 数据管线与发布
3.1 数据目录结构与打包形态（文档）

 在 需求/子系统设计概要.md 2.7 中写明：

 源配置目录：

/Data/Items/*.yaml

/Data/Skills/*.yaml

/Data/Quests/*.yaml

/Data/Npcs/*.yaml

/Data/Dialogs/*.yaml

/Data/Terrain/*.yaml

 源美术/音频目录（mgcb 输入）：

/ContentSrc/Textures/…

/ContentSrc/Audio/…

/ContentSrc/Fonts/…

 构建输出：

/Build/Config/items.json、skills.json…（合并后的 JSON）

/Content/**.xnb（由 mgcb WindowsDX 配置生成，纹理启用 mipmap，音频使用 OGG 输入）

 明确：

 v0.2 静态配置全部通过 JSON 提供给 C#；

 SQLite 仅负责存档/日志，不存静态配置。

3.2 Python 工具与版本/校验

 Python 侧：

 定义统一的数据模型（data_models.py）与 C# DTO 对齐

 build_configs.py：

 读取 Data/*.yaml

 进行字段校验（必填字段、ID 唯一性、引用存在性）

 合并输出为 Build/Config/*.json

 为输出添加简单版本号（config_version，写入 JSON 顶层）

 C# 侧：

 IGameConfigProvider 读取所有 JSON

 在启动时打印配置版本号

 在文档中标记：

 v0.2 不做自动 schema 同步/代码生成，完全手控；

 v0.3+ 再考虑用脚本生成 C# DTO。

4. 脚本层（仅设计，不落地完整实现）
4.1 脚本策略占位

 在 需求/框架设计清单.md 8.1 里写清：

 v0.2：不引入外部脚本语言，所有逻辑用 C#，但：

 在 Event/Quest/Dialogue 等系统中通过接口/枚举抽象行为

 v1.0：候选脚本方案 —— Lua 或 C# 热重载（Roslyn/反射）

 确保：

 事件系统中的 ActionType / ConditionType 可以映射到未来的脚本调用点

 不把所有逻辑死写在 UI 代码里。

5. 存档 / SQLite 细化
5.1 表结构落地

 在 需求/子系统设计概要.md 2.7.2 编写 v0.2 存档表结构，字段如下：

 Saves(id PK, name TEXT, created_at INT, updated_at INT, play_time INT, world_seed TEXT, schema_version INT)

 PlayerState(save_id PK/FK, scene_id TEXT, pos_x REAL, pos_y REAL, pos_z REAL, hp REAL, mp REAL, level INT, exp INT)

 Inventory(save_id FK, slot INT, item_id TEXT, qty INT, PRIMARY KEY(save_id, slot))

 Equipment(save_id FK, slot TEXT, item_id TEXT, PRIMARY KEY(save_id, slot))

 QuestState(save_id FK, quest_id TEXT, status INT, progress_json TEXT, PRIMARY KEY(save_id, quest_id))

 WorldFlags(save_id FK, key TEXT, value TEXT, PRIMARY KEY(save_id, key))

 CombatLog：可选（推迟实现）

 在 Engine.Data.SaveRepository 中：

 实现上述表的增删查改；完成一次“新建存档 → 写入 → 读回恢复”的闭环。

5.2 版本与安全

 存档版本策略：

 SAVE_SCHEMA_VERSION = 1（常量），写入 Saves.schema_version

 读档时如版本不符，拒绝加载并提示用户

 写档前创建 .bak 备份（简单复制旧文件）

 异步写入/压缩列为 v0.3 优化方向，v0.2 仅留 TODO 注释。

6. 输入 / 操作映射
6.1 动作映射框架

 定义 Action 枚举（MoveUp/MoveDown/MoveLeft/MoveRight/Shoot/Skill1/Interact/Pause 等）

 实现：

 InputActionMap：键位 → Action 的映射

 IInputManager.GetActionState(Action) 接口（Pressed / Held / Released）

 玩家控制组件只依赖 Action，不直接读键值。

6.2 重绑与手柄（设计层）

 在文档中描述：

 v0.2：不提供 UI 重绑，只支持配置文件修改

 提前定义键位配置文件格式，例如 /Config/input_mappings.json

 手柄支持写入“未来计划”章节

 UI 焦点切换：

 设计 UIFocusManager 接口，v0.2 只支持简单菜单切换。

7. 音频子系统
7.1 最小音频框架

 在 Engine.Audio 新增模块：

 IAudioManager

 PlayBgm(string trackId, loop) —— OGG 44.1kHz 流式播放，单实例，淡入淡出 0.5–1.0s

 PlaySfx(string sfxId) —— 预加载 SoundEffect，最大并发 32（同 id 默认限 4 并发，之后丢弃/复用）

 音量控制（Master/BGM/SFX，0–1，对数曲线）

 采用 MonoGame 内置音频 API，输入文件统一为 OGG。

7.2 触发管线

 将以下事件接入音频：

 场景切换 → 切换 BGM

 玩家攻击/受击 → 播放特定 SE

 UI 操作（按钮点击、打开菜单）→ SE

 战斗事件后续逐步接入（按需扩展）。

8. 动画与特效
8.1 2D 动画基础

 在 Engine.Rendering.Animation：

 SpriteAnimation（单个序列帧动画）

 AnimationStateMachine（Idle/Move/Attack/Death）

 为实体增加 AnimationComponent：

 驱动 Renderer 播放对应动画

 与角色状态/技能释放联动

8.2 粒子系统基础

 在 Engine.Rendering.Particles：

 最小粒子系统支持：

 子弹拖尾

 爆炸火花

 简易环境效果（雨/雪）

 提供接口：

 SpawnParticleEffect(effectId, position)

9. 资源导入 / 打包 / 热重载
9.1 最小资源加载约定

 在 需求/子系统设计概要.md 写明：

 纹理/音频/字体均通过 mgcb 生成 XNB，输入放 /ContentSrc/Textures、/ContentSrc/Audio、/ContentSrc/Fonts，输出统一放 /Content。

 配置路径规则：/Build/Config/*.json（静态数据）、/Data/Texts/*.yaml → /Build/Config/texts_xx.json

 在 Engine.Core.AssetManager 中：

 对纹理/音频/字体/配置建立统一加载缓存接口，运行时仅读 XNB + /Build/Config。

9.2 热重载（最小开发向）

 v0.2 不做正式热重载，但：

 保留一个开发模式下的“按键触发重新加载配置”的调试函数（例如 F5 重新加载 JSON 配置）

 文档中标记未来计划：文件监控 → 自动热重载。

10. 性能与并发支撑（设计占位）
10.1 空间分区与裁剪

 在 Engine.World 中：

 设计一个简单的空间分区接口（如 ISpatialPartition）

 v0.2 实现 Grid/Chunk 级别的划分（用于实体查询/渲染裁剪）

 在渲染时：

 只渲染摄像机视口附近的地形块/实体

10.2 未来 Job 系统（仅文档）

 在文档中说明：

 v0.2 不实现多线程 Job 系统

 标出可能异步化的任务（地形生成、路径查找、大量 AI 更新）

 为将来添加 JobSystem 保留接口。

11. 文本 / 字体 / 本地化
11.1 文本资源管理

 引入 TextId 概念（不要在 UI 代码中直接写中文），命名规范如 ui.menu.start、dialog.npc01.hello。

 在 /Data/Texts/zh_CN.yaml 中维护 UI 文本/对话文本，构建到 /Build/Config/texts_zh_CN.json。

 C# 中：

 TextManager 加载对应语言文件；GetText(TextId)；缺字/缺 key 时返回 [MISSING:<key>] 并写日志。

11.2 字体与缺字回退

 使用可商用中文字体（例如 Noto Sans SC），放 /ContentSrc/Fonts/NotoSansSC-Regular.ttf，mgcb 生成 SpriteFont。

 HUD 默认字号 28，对话 32，覆盖常用中英标点区间；同一字体作为缺字回退。

 本地化多语言：v0.2 固定 zh-CN，多语言计划写入 v1.0。

12. 测试与诊断
12.1 Debug HUD & 控制台

 Debug HUD：

 显示：FPS、实体数量、当前场景 ID、内存估计

 可通过快捷键开关（如 F3）

 Debug 控制台：

 支持简单命令：teleport, spawn, give_item, set_time 等

 仅开发模式可用

12.2 最小自动化 / 性能基准

 为关键系统编写少量单元测试（例如：

 Stat 合成逻辑

 存档读写完整性

 地形生成参数 → 结果高度范围）

 建立一个简单的性能场景：

 大量敌人/子弹/特效

 手动记录/观察帧率，作为后续优化基线
