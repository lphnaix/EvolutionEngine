1. 平台与图形后端
1.1 目标平台矩阵（文档）

 在 需求/子系统设计概要.md 中补充「目标平台与硬件」章节：

 v0.2 明确：

 OS：优先支持 Windows 10+（x64）

 图形 API：MonoGame（DirectX 或 OpenGL 二选一，写死一个）

 输入设备：键盘 + 鼠标（手柄写成后续计划）

 推荐分辨率：1080p / 1440p，最低目标帧率 60 FPS

 最低硬件建议：集显/轻量独显的粗略级别即可描述

 标明：其他平台（Linux/macOS、手柄）放入 v0.3+ 规划。

1.2 图形后端选择与封装（代码）

 在 Engine.Platform / Engine.Rendering 中写死 v0.2 使用的实际后端（例如 MonoGame DX）

 抽象出：

 IRenderer

 IInputManager

 IGameWindow

 确保未来更换图形后端时，不影响上层模块。

2. HD-2D 渲染细节
2.1 相机 & 深度模型定稿（文档 + 代码）

 在 需求/框架设计清单.md 3.1 内明确：

 v0.2 使用 正交相机（Orthographic）

 地形 + 实体使用 Z-buffer + 层级深度 进行排序，不再依赖“按 Y 值排序”的 2D 老套路

 在 Engine.Rendering.Camera 中实现正交相机矩阵

2.2 地形表现方案

 在文档明确：

 v0.2 地形方案是：

 方案 A：Tile + 高度信息（但渲染上仍是 tile-based）

或

 方案 B：由 HeightMap 生成 mesh（优先选一个，写死）

 在 Engine.World.Terrain 内：

 定下最终 Terrain 数据结构（Tile/HeightMap 的字段）

 渲染层：提供 BuildTerrainMesh() 或 DrawTerrainTiles() 的统一接口

2.3 光源 / 法线 / 后处理的最小实现

 在 需求/框架设计清单.md 中补充 v0.2 光照目标：

 至少一个全局方向光（或环境光）

 将来支持点光源，但 v0.2 可只做接口

 在 Engine.Rendering 中：

 设计 Light 结构（方向光 / 点光源 / 颜色 / 强度）

 为 sprite/地形预留 normal map 支持（纹理通道 + 材质参数）

 后处理顺序（v0.2 最小版，全部可选开启/关闭）：

 渲染场景 → 可选 Bloom → UI Overlay

 在文档中简单描述“当前 pipeline”。

3. 数据管线与发布
3.1 数据目录结构与打包形态（文档）

 在 需求/子系统设计概要.md 2.7 中写明：

 源数据目录：

/Data/Items/*.yaml

/Data/Skills/*.yaml

/Data/Quests/*.yaml

/Data/Npcs/*.yaml

/Data/Dialogs/*.yaml

/Data/Terrain/*.yaml

 构建输出目录：

/Build/Config/items.json

/Build/Config/skills.json

...（合并后的 JSON）

 明确：

 v0.2 静态配置全部通过 JSON 提供给 C#

 SQLite 仅负责存档/日志，不存静态配置（或只作为可选）。

3.2 Python 工具与版本/校验

 Python 侧：

 定义统一的数据模型（data_models.py）与 C# DTO 对齐

 build_configs.py：

 读取 Data/*.yaml

 进行字段校验（必填字段、ID 唯一性、引用存在性）

 合并输出为 Build/Config/*.json

 为输出添加简单版本号（config_version，写入 JSON 顶层）

 C# 侧：

 IGameConfigProvider 读取所有 JSON

 在启动时打印配置版本号

 在文档中标记：

 v0.2 不做自动 schema 同步/代码生成，完全手控；

 v0.3+ 再考虑用脚本生成 C# DTO。

4. 脚本层（仅设计，不落地完整实现）
4.1 脚本策略占位

 在 需求/框架设计清单.md 8.1 里写清：

 v0.2：不引入外部脚本语言，所有逻辑用 C#，但：

 在 Event/Quest/Dialogue 等系统中通过接口/枚举抽象行为

 v1.0：候选脚本方案 —— Lua 或 C# 热重载（Roslyn/反射）

 确保：

 事件系统中的 ActionType / ConditionType 可以映射到未来的脚本调用点

 不把所有逻辑死写在 UI 代码里。

5. 存档 / SQLite 细化
5.1 表结构落地

 在 需求/子系统设计概要.md 2.7.2 编写 v0.2 存档表结构，至少包括：

 Saves：存档元信息（id, name, created_at, updated_at, play_time, world_seed, schema_version）

 PlayerState：位置、HP/MP、等级、经验、当前场景

 Inventory：物品 ID、数量、槽位

 Equipment：槽位 → 物品 ID

 QuestState：任务 ID、状态、进度 JSON

 WorldFlags：key-value 状态位

 CombatLog：可选，用于分析（可推迟实现）

 在 Engine.Data.SaveRepository 中：

 实现上述表的增删查改

 完成一次“新建存档 → 写入 → 读回恢复”的闭环。

5.2 版本与安全

 存档版本策略：

 在 Saves 中增加 schema_version 字段

 v0.2 定义版本常量，如 SAVE_SCHEMA_VERSION = 1

 读档时如果版本不匹配，给出提示/拒绝加载（简单处理）

 异步写入/压缩（写文档说明，不必实现）：

 标记为 v0.3 优化方向

 只在 v0.2 中留 TODO 注释。

6. 输入 / 操作映射
6.1 动作映射框架

 定义 Action 枚举（MoveUp/MoveDown/MoveLeft/MoveRight/Shoot/Skill1/Interact/Pause 等）

 实现：

 InputActionMap：键位 → Action 的映射

 IInputManager.GetActionState(Action) 接口（Pressed / Held / Released）

 玩家控制组件只依赖 Action，不直接读键值。

6.2 重绑与手柄（设计层）

 在文档中描述：

 v0.2：不提供 UI 重绑，只支持配置文件修改

 提前定义键位配置文件格式，例如 /Config/input_mappings.json

 手柄支持写入“未来计划”章节

 UI 焦点切换：

 设计 UIFocusManager 接口，v0.2 只支持简单菜单切换。

7. 音频子系统
7.1 最小音频框架

 在 Engine.Audio 新增模块：

 IAudioManager

 PlayBgm(string trackId, loop)

 PlaySfx(string sfxId)

 音量控制（Master/BGM/SFX）

 调用 MonoGame/FNA 内置音频 API 做简单实现

7.2 触发管线

 将以下事件接入音频：

 场景切换 → 切换 BGM

 玩家攻击/受击 → 播放特定 SE

 UI 操作（按钮点击、打开菜单）→ SE

8. 动画与特效
8.1 2D 动画基础

 在 Engine.Rendering.Animation：

 SpriteAnimation（单个序列帧动画）

 AnimationStateMachine（Idle/Move/Attack/Death）

 为实体增加 AnimationComponent：

 驱动 Renderer 播放对应动画

 与角色状态/技能释放联动

8.2 粒子系统基础

 在 Engine.Rendering.Particles：

 最小粒子系统支持：

 子弹拖尾

 爆炸火花

 简易环境效果（雨/雪）

 提供接口：

 SpawnParticleEffect(effectId, position)

9. 资源导入 / 打包 / 热重载
9.1 最小资源加载约定

 在 需求/子系统设计概要.md 写明：

 纹理路径规则（如 /Content/Textures/...）

 音频路径规则（如 /Content/Audio/...）

 配置路径规则（/Build/Config/*.json）

 在 Engine.Core.AssetManager 中：

 对纹理/音频/配置建立统一加载缓存接口

9.2 热重载（最小开发向）

 v0.2 不做正式热重载，但：

 保留一个开发模式下的“按键触发重新加载配置”的调试函数（例如 F5 重新加载 JSON 配置）

 文档中标记未来计划：文件监控 → 自动热重载。

10. 性能与并发支撑（设计占位）
10.1 空间分区与裁剪

 在 Engine.World 中：

 设计一个简单的空间分区接口（如 ISpatialPartition）

 v0.2 实现 Grid/Chunk 级别的划分（用于实体查询/渲染裁剪）

 在渲染时：

 只渲染摄像机视口附近的地形块/实体

10.2 未来 Job 系统（仅文档）

 在文档中说明：

 v0.2 不实现多线程 Job 系统

 标出可能异步化的任务（地形生成、路径查找、大量 AI 更新）

 为将来添加 JobSystem 保留接口。

11. 文本 / 字体 / 本地化
11.1 文本资源管理

 引入 TextId 概念（不要在 UI 代码中直接写中文）

 在 /Data/Texts/zh_CN.yaml 中维护 UI 文本/对话文本

 C# 中：

 TextManager 加载对应语言文件

 提供 GetText(TextId) 接口

11.2 字体与缺字回退

 在渲染层确定：

 使用一套支持中文的 TTF/OTF 字体

 测试 HUD/对话框中文字渲染

 本地化多语言：

 写进文档：“v0.2 固定 zh-CN；多语言支持放入 v1.0”。

12. 测试与诊断
12.1 Debug HUD & 控制台

 Debug HUD：

 显示：FPS、实体数量、当前场景 ID、内存估计

 可通过快捷键开关（如 F3）

 Debug 控制台：

 支持简单命令：teleport, spawn, give_item, set_time 等

 仅开发模式可用

12.2 最小自动化 / 性能基准

 为关键系统编写少量单元测试（例如：

 Stat 合成逻辑

 存档读写完整性

 地形生成参数 → 结果高度范围）

 建立一个简单的性能场景：

 大量敌人/子弹/特效

 手动记录/观察帧率，作为后续优化基线